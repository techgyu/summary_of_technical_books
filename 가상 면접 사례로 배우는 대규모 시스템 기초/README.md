# 가상 면접 사례로 배우는 대규모 시스템 기초

## 1. 책 기본 정보
- 제목: 가상 면접 사례로 배우는 대규모 시스템 기초
- 저자: 알렉스 쉬 지음 | 이병준 옮김

## 2. 목차 및 챕터별 핵심 내용
- 문제 이해 및 설계 범위 확정
- 개략적 설계안 제시 및 동의 구하기
- 상세 설계
- 마무리

### 1장. 사용자 수에 따른 규모 확장성
**핵심 내용**
1. 웹 계층은 무상태(stateless)로 설계하여 확장성과 유지보수를 용이하게 한다.
2. 모든 계층에 다중화(Redundancy)를 도입해 장애에 강한 구조를 만든다.
3. 가능한 한 많은 데이터를 캐시하여 응답 속도를 높이고 서버 부하를 줄인다.
4. 여러 데이터 센터를 지원해 장애 발생 시 서비스 연속성을 보장한다.
5. 정적 콘텐츠는 CDN(콘텐츠 전송 네트워크)을 통해 전 세계 사용자에게 빠르게 제공한다.
6. 데이터 계층은 샤딩(Sharding)으로 확장성을 확보한다.
7. 각 계층은 독립적인 서비스로 분리해 관리와 확장성을 높인다.
8. 시스템을 지속적으로 모니터링하고, 자동화 도구를 적극 활용해 운영 효율성을 높인다.

### 2장. 개략적인 규모 추정
**핵심 내용**
1. 데이터 단위는 2의 제곱수로 계산하며, 최소 단위는 1바이트(8비트)이다.
2. 메모리는 빠르지만 디스크는 상대적으로 느리므로, 디스크 탐색을 최소화해야 한다.
3. 단순한 압축 알고리즘은 빠르며, 데이터를 전송하기 전에는 압축을 활용한다.
4. 데이터 센터는 여러 지역(region)에 분산되어 있고, 센터 간 데이터 전송에는 시간이 소요된다.
5. 사용자 수, 일일 사용자 수, 게시글 수, 미디어 포함 게시글 수, 데이터 보관 기간 등 다양한 요소를 고려해 QPS(Query Per Second)와 저장소 요구량을 산출한다.

### 3장. 시스템 설계 면접 공략법
**핵심 내용**
1. 문제 이해 및 설계 범위 확정 → 개략적 설계안 제시 및 동의 구하기 → 상세 설계 → 마무리(후속 질의 및 추가 논의) 순으로 접근한다.
2. 반드시 질문을 통해 요구사항과 가정을 명확히 하고, 스스로 내린 가정에만 의존하지 않는다.
3. 정답이나 최선의 답안은 없으며, 사고의 흐름을 면접관이 이해할 수 있도록 설명한다.
4. 여러 해법을 제시하고, 개략적 설계에 면접관이 동의하면 각 컴포넌트의 세부 설계를 진행한다. 가장 중요한 컴포넌트부터 상세히 설계한다.
  
### 4장. 처리율 제한 장치의 설계
**핵심 내용**
1. 목적: 클라이언트 또는 서비스가 보내는 트래픽의 처리율(rate)을 제어하여 시스템 자원을 보호하고, 서비스 품질을 유지한다.
2. 동작 예시:
   - 사용자는 초당 2회 이상 새 글을 올릴 수 없다.
   - 같은 IP 주소로는 하루에 10개 이상의 계정을 생성할 수 없다.
   - 같은 디바이스로는 주당 5회 이상 리워드(reward)를 요청할 수 없다.
3. 사용할 수 있는 알고리즘:
   - **토큰 버킷(Token Bucket)**: 일정 시간마다 토큰이 버킷에 추가되고, 요청이 올 때마다 토큰을 소모. 토큰이 있으면 요청 허용, 없으면 거부. 순간적인 버스트 트래픽도 허용 가능.
   - **누출 버킷(Leaky Bucket)**: 고정 크기의 버킷에 요청이 들어오고, 일정한 속도로만 처리. 버킷이 넘치면 초과 요청은 폐기. 트래픽을 평탄하게 만듦.
   - **고정 윈도 카운터(Fixed Window Counter)**: 일정 시간(예: 1분) 동안의 요청 수를 카운트. 윈도 단위로 제한을 적용.
   - **이동 윈도 로그(Sliding Window Log)**: 각 요청의 타임스탬프를 기록하고, 최근 N초(분) 내 요청 수를 계산해 제한.
   - **이동 윈도 카운터(Sliding Window Counter)**: 여러 고정 윈도 카운터를 조합해, 시간 경계에서의 부드러운 제한을 구현.
4. 장점:
   - DoS/DDoS 공격에 의한 자원 고갈을 방지한다.
   - 불필요한 트래픽을 제한하여 비용을 절감한다.
   - 서버 과부하를 방지하고, 서비스의 안정성을 높인다.
5. 설계 방법:
   - 3장의 "문제 이해 및 설계 범위 확정 → 개략적 설계안 제시 및 동의 구하기 → 상세 설계 → 마무리(후속 질의 및 추가 논의)" 프로세스를 따른다.
6. 분산 서버 환경에서의 주요 이슈 및 해결책:
   - 경쟁 조건(Race Condition): 병렬 데이터 접근 시 Lock, Lua-script, Redis의 정렬 집합(sorted set) 등으로 동기화한다.
   - 동기화(Synchronization): 여러 처리율 제한 장치 간의 데이터 일관성 유지가 필요하며, 중앙 집중식 데이터 저장소(예: Redis) 또는 분산 락을 활용한다.
   - 클럭 드리프트(Clock Drift): 분산 환경에서 서버 간 시간 차이로 인한 문제를 고려해야 하며, NTP 등 시간 동기화 시스템을 도입한다.
   - 장애 복구: 처리율 제한 정책이 장애 시에도 일관되게 동작하도록 설계한다.
7. 실무 팁:
   - 처리율 제한 정책은 비즈니스 요구사항에 따라 유연하게 조정할 수 있어야 한다.
   - 정책 우회(예: 프록시, VPN 등)에 대한 방어책도 필요하다.

### 5장. 안정 해시 설계
**핵심 내용**
1. 안정 해시(Consistent Hashing)의 장점:
   - 서버가 추가되거나 삭제될 때 재배치되는 키의 수가 전체의 일부(최소화)로 제한된다.
   - 데이터가 균등하게 분포되어 수평적 규모 확장(Scale-out)이 용이하다.
   - 핫스팟(hotspot) 키 문제를 줄여 특정 샤드(Shard)에 부하가 집중되는 현상을 완화한다.
2. 기존 해시 분배 방식의 문제점:
   - 서버 장애 시, 해당 서버에 있던 키뿐 아니라 대부분의 키가 재분배되어 캐시 효율이 급격히 저하된다.
   - 예를 들어, 1번 서버가 죽으면 대부분의 캐시 클라이언트가 데이터가 없는 서버에 접속하게 된다.
3. 안정 해시란?
   - 해시 공간을 원형(서클)으로 표현하고, 서버와 키를 모두 해시 공간에 매핑한다.
   - 각 키는 해시 공간상에서 시계방향으로 가장 가까운 서버에 할당된다.
   - 서버가 추가/삭제될 때, 해당 서버에 할당된 키만 재배치되므로 전체 데이터 이동량이 최소화된다.
   - "키의 개수 / 슬롯 개수"만큼의 키만 재배치되는 구조로, 대규모 분산 시스템에서 매우 효과적이다.
4. 실무 팁:
   - 가상 노드(Virtual Node) 개념을 도입하면 데이터 분포의 불균형을 더욱 줄일 수 있다.
   - 분산 캐시, 분산 데이터베이스, 샤딩 시스템 등에서 널리 사용된다.

### 6장. 키-값 저장소 설계
**핵심 내용**
1. 키-값 저장소란?
   - 각 데이터(값)는 고유한 키를 통해서만 접근할 수 있는 단순한 데이터 저장 구조.
   - 대표적인 예: Redis, DynamoDB, Memcached 등.
2. 단일 서버 키-값 저장소:
   - 모든 키-값 쌍을 메모리 내 해시 테이블로 저장.
   - 빠른 접근이 가능하지만, 서버 장애 시 데이터 손실 위험이 크고 확장성이 제한됨.
3. 분산 키-값 저장소와 CAP 이론:
   - CAP 정리: 일관성(Consistency), 가용성(Availability), 파티션 감내성(Partition Tolerance) 세 가지를 동시에 완벽히 만족하는 분산 시스템은 불가능.
     - 일관성: 모든 노드에서 항상 동일한 데이터 보장.
     - 가용성: 일부 노드 장애에도 항상 응답 제공.
     - 파티션 감내성: 네트워크 분할(파티션) 상황에서도 시스템이 동작.
   - CP(일관성+파티션 감내), AP(가용성+파티션 감내) 시스템이 실무에서 주로 사용됨. CA(일관성+가용성) 시스템은 현실적으로 존재하지 않음.
4. 비일관성 해소 기법: 데이터 버저닝과 벡터 시계
   - 버저닝: 데이터 변경 시마다 새로운 버전을 생성해 충돌을 관리.
   - 벡터 시계(Vector Clock): 각 버전의 변경 이력을 추적해 충돌 여부를 판단.
   - 버전 X와 Y의 충돌 여부는 Y의 벡터 시계 값 중 X의 동일 서버 값보다 작은 것이 있는지로 판단.
5. 분산 키-값 저장소의 필수 기능과 구현 기술:
   - **대규모 데이터 저장**: 안정 해시(Consistent Hashing)를 사용해 데이터를 여러 서버에 균등하게 분산. 서버 추가/삭제 시 데이터 이동량 최소화.
   - **읽기 연산의 높은 가용성**: 데이터를 여러 데이터센터에 복제(Replication)하여, 일부 서버 장애 시에도 읽기 연산이 가능하도록 함. 예: DynamoDB, Cassandra의 다중 리전 복제.
   - **쓰기 연산의 높은 가용성**: 버저닝과 벡터 시계를 통해 여러 노드에서 동시에 쓰기 연산이 발생해도 충돌을 감지하고, 나중에 병합(Merge)할 수 있도록 설계. 예: Dynamo의 이벤트추적 기반 병합.
   - **데이터 파티셔닝**: 안정 해시를 활용해 키 공간을 여러 서버(샤드)로 분할. 각 샤드는 전체 데이터의 일부만 저장해 확장성과 관리 효율성을 높임.
   - **점진적 규모 확장성**: 서버를 추가/제거할 때 전체 데이터 재분배가 아닌 일부 데이터만 이동. 안정 해시와 가상 노드(Virtual Node) 활용.
   - **다양성(heterogeneity) 지원**: 서버의 성능이나 용량이 다를 때, 가상 노드 개수를 조절해 부하를 균등하게 분산.
   - **조절 가능한 데이터 일관성**: 정족수 합의(Quorum Consensus)를 통해 읽기/쓰기 연산의 일관성 수준을 조절. 예: W+R>N(쓰기/읽기/복제본 수) 조건으로 강한 일관성 보장.
   - **일시적 장애 처리**: 느슨한 정족수 프로토콜(Sloppy Quorum)과 단서 후 임시 위탁(Hinted Handoff)으로 일시적 네트워크 장애 시에도 데이터 손실 없이 복구.
   - **영구적 장애 처리**: 머클 트리(Merkle Tree)를 사용해 노드 간 데이터 불일치(분기점)를 효율적으로 탐지하고, 동기화(Synchronization) 수행.
   - **데이터센터 장애 대응**: 여러 데이터센터에 데이터 복제 및 자동 장애 조치(Failover)로 전체 서비스의 가용성 보장.
6. 실무 팁:
   - 분산 키-값 저장소는 확장성, 가용성, 일관성 요구사항에 따라 설계 전략이 달라진다.
   - 데이터 일관성 수준은 비즈니스 요구에 맞게 조정해야 하며, 장애 복구와 데이터 동기화 전략도 중요하다.

### 7장. 분산 시스템을 위한 유일 ID 생성기 설계
**핵심 내용**
1. 필요한 이유:
   - 전통적인 auto_increment(자동 증가) 방식은 단일 데이터베이스 환경에서는 간단하지만, 분산 데이터베이스 환경에서는 중복/충돌 위험이 있어 사용할 수 없음.
   - 대규모 분산 시스템에서는 각 노드/서버/데이터센터에서 동시에 안전하게 유일한 ID를 생성해야 함.
2. 분산 시스템에서 유일성이 보장되는 ID 생성 방법:
   - **다중 마스터 복제(Multi-master Replication)**:
     - 각 데이터베이스 서버가 auto_increment 값을 k(서버 수)만큼 증가시키는 방식.
     - 예: 3대 서버라면 각각 1, 4, 7... / 2, 5, 8... / 3, 6, 9... 식으로 ID를 할당.
     - 서버 수가 늘거나 줄면 관리가 복잡해지고, ID의 연속성이 깨질 수 있음.
   - **UUID(Universally Unique Identifier)**:
     - 128비트 크기의 고유 식별자. 충돌 가능성이 극히 낮음.
     - 초당 10억 개의 UUID를 100년간 생성해도 중복 확률이 50%에 불과.
     - 단점: 길이가 길고, 인덱스/정렬 효율이 떨어질 수 있음.
   - **티켓 서버(Ticket Server)**:
     - 중앙 집중형 서버에서 auto_increment로 ID를 발급.
     - 구현이 단순하지만, SPOF(Single Point of Failure, 단일 장애점) 문제가 발생.
     - 대규모 시스템에는 적합하지 않음.
   - **트위터 스노플레이크(Twitter Snowflake) 접근법**:
     - 64비트 정수형 ID를 사용하며, 다음과 같은 필드로 구성:
       - 사인 비트(1): 항상 0
       - 타임스탬프(41): 밀리초 단위의 시간 정보
       - 데이터센터 ID(5): 데이터센터 구분
       - 서버 ID(5): 서버 구분
       - 일련번호(12): 같은 밀리초 내 여러 ID 생성 시 증가
     - 장점: 전역적으로 유일하고, 시간 순서대로 정렬 가능하며, 분산 환경에서 충돌 없이 빠르게 ID 생성 가능
     - 단점: 시스템 시간이 역행하면(Clock Drift) 중복 위험이 있으므로 시간 동기화가 중요
3. 실무 팁:
   - ID 생성기는 시스템의 확장성, 장애 허용성, 관리 편의성 등을 고려해 선택해야 함.
   - Snowflake 방식은 대규모 분산 시스템에서 널리 사용되며, 오픈소스 구현체도 다양함.
   - UUID는 외부 시스템 연동이나 글로벌 유일성이 필요한 경우에 적합.

### 8장. URL 단축기 설계
- 


### 9장. 웹 크롤러 설계
- 

### 10장. 알림 시스템 설계
- 

  ### 11장. 뉴스 피드 시스템 설계
- 

  ### 12장. 채팅 시스템 설계
- 

  ### 13장. 검색어 자동완성 시스템
- 

  ### 14장. 유튜브 설계
- 

  ### 15장. 구글 드라이브 설계
- 

  ### 16장. 배움은 계속된다
- 

## 3. 전체 요약 (3~5줄)
- 대형시스템의 설계는 문제 이해 및 설계 범위 확정 → 개략적 설계안 제시 및 동의 구하기 → 상세 설계 → 마무리(후속 질의 및 추가 논의) 순으로 접근한다.
- 대규모 시스템 설계는 확장성, 가용성, 일관성, 장애 대응 등 다양한 요구사항을 균형 있게 고려해야 하며, 각 계층의 역할과 분산 환경의 특성을 이해하는 것이 중요하다.
- 처리율 제한, 안정 해시, 분산 키-값 저장소, 유일 ID 생성 등 핵심 기술들은 실무에서 빈번히 활용되며, 각 기술의 장단점과 구현 방법을 명확히 파악해야 한다.
- 설계 과정에서는 문제 정의, 요구사항 분석, 개략적/상세 설계, 실무 적용 및 장애 대응 전략까지 체계적으로 접근해야 한다.
- 실무에서는 자동화, 모니터링, 정책 유연성, 장애 복구 등 운영 관점의 고려도 필수적이다.

## 4. 주요 개념/키워드
- **확장성(Scalability)**: 시스템이 사용자나 데이터 증가에 따라 성능 저하 없이 확장될 수 있는 능력
- **가용성(Availability)**: 시스템이 장애 상황에서도 지속적으로 서비스를 제공할 수 있는 능력
- **일관성(Consistency)**: 모든 노드에서 항상 동일한 데이터가 보장되는 성질
- **파티션 감내성(Partition Tolerance)**: 네트워크 분할 상황에서도 시스템이 동작을 멈추지 않는 성질
- **샤딩(Sharding)**: 데이터를 여러 서버(샤드)로 분산 저장하는 기술
- **캐시(Cache)**: 자주 사용하는 데이터를 임시로 저장해 빠르게 접근하는 기술
- **로드 밸런싱(Load Balancing)**: 여러 서버에 트래픽을 고르게 분산하는 기술
- **CDN(콘텐츠 전송 네트워크)**: 전 세계에 분산된 서버를 통해 정적 콘텐츠를 빠르게 제공하는 네트워크
- **처리율 제한(Rate Limiting)**: 단위 시간당 요청 수를 제한해 시스템 자원을 보호하는 기법
- **토큰 버킷(Token Bucket)**: 일정 시간마다 토큰을 추가해 요청을 허용하는 처리율 제한 알고리즘
- **누출 버킷(Leaky Bucket)**: 고정 속도로 요청을 처리해 트래픽을 평탄하게 만드는 알고리즘
- **고정/이동 윈도 카운터/로그(Fixed/Sliding Window Counter/Log)**: 시간 구간별로 요청 수를 제한하는 처리율 제한 알고리즘
- **안정 해시(Consistent Hashing)**: 서버 추가/삭제 시 데이터 이동량을 최소화하는 해시 분산 기법
- **가상 노드(Virtual Node)**: 데이터 분포의 불균형을 줄이기 위해 논리적으로 여러 노드로 분할하는 기법
- **CAP 이론(CAP Theorem)**: 분산 시스템에서 일관성, 가용성, 파티션 감내성 중 두 가지만 동시에 보장할 수 있다는 이론
- **버저닝(Versioning)**: 데이터 변경 시마다 새로운 버전을 생성해 충돌을 관리하는 기법
- **벡터 시계(Vector Clock)**: 분산 환경에서 데이터 변경 이력을 추적해 충돌 여부를 판단하는 기법
- **정족수 합의(Quorum Consensus)**: 읽기/쓰기 연산의 일관성 수준을 조절하는 합의 방식
- **머클 트리(Merkle Tree)**: 데이터 동기화 및 무결성 검증에 사용되는 트리 구조
- **UUID**: 전역적으로 유일한 128비트 식별자
- **트위터 스노플레이크(Snowflake)**: 시간, 서버, 일련번호 등으로 구성된 64비트 분산 고유 ID 생성 방식
- **티켓 서버(Ticket Server)**: 중앙 서버에서 순차적으로 ID를 발급하는 방식
- **분산 시스템(Distributed System)**: 여러 서버가 네트워크로 연결되어 하나의 시스템처럼 동작하는 구조
- **장애 복구(Failover)**: 장애 발생 시 자동으로 대체 시스템으로 전환하는 기능
- **데이터 파티셔닝(Data Partitioning)**: 데이터를 여러 파티션(서버)에 나누어 저장하는 기법
- **데이터 다중화(Replication)**: 데이터를 여러 서버에 복제해 가용성과 내구성을 높이는 기법
- **클럭 드리프트(Clock Drift)**: 분산 서버 간 시간 차이로 인한 문제
- **SPOF(Single Point of Failure)**: 단일 장애점, 한 곳이 장애나면 전체 시스템이 멈추는 구조
- **슬로피 쿼럼(Sloppy Quorum)**: 일부 노드 장애 시에도 임시로 다른 노드에 데이터를 저장하는 프로토콜
- **힌티드 핸드오프(Hinted Handoff)**: 장애 노드가 복구되면 임시로 저장된 데이터를 다시 전달하는 기법
